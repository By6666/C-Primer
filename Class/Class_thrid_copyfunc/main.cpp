#include <iostream>
using namespace std;


//*********复制构造函数就是拷贝构造函数，区别于赋值构造函数****
//1、对象不存在，且没用别的对象来初始化，就是调用了构造函数；
//2、对象不存在，且用别的对象来初始化，就是拷贝构造函数（上面说了三种用它的情况！）
//3、对象存在，用别的对象来给它赋值，就是赋值函数。

//***************复制构造函数发生的情况*************
//1、定义一个对象时，以本类另一个对象作为初始值，发生复制构造
//2、如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造
//3、如果函数的返回值是类的对象，函数执行完成返回主函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造  
//**************************************************


//******************隐含复制构造函数*****************
//1、如果程序员没有为类声明复制构造函数，则编译器自己生成一个隐含的复制构造函数
//2、这个构造函数执行的功能是：用初始值对象的每个数据成员初始化将要建立的对象的对应数据成员
//***************************************************

//自我理解：
//类对象在传递时，不像其他类型那样可以直接赋值传递，而类对象的传递只能通过复制构造函数来建立，这个过程就像其他类型那样的赋值传递，
//只不过类对象的传递较为特殊。复制构造函数为以后类对象在函数间的传递提供了便利，可以通过你想要的结果来写复制构造函数


class Point
{
public:
	Point(int xx = 0, int yy = 0)        //构造函数
		:x(xx), y(yy)
	{}
	//如果自己不写的复制构造函数，那么编译器会自动生成一个复制构造函数，编译器自己生成复制构造函数就是简单的一一复制
	Point(const Point &P);                //复制构造函数

	int get_X() { return x; }
	int get_Y() { return y; }

private:
	int x, y;

};


Point::Point(const Point &P)             //复制构造函数实现
{                                        //如果自己写了复制构造函数，就不会生成默认的复制构造函数，那么复制就成了选择性复制
	x = P.x;
//	y = P.y;
	cout << "Copy succeed !!" << endl;
}

void fun1(Point p)                      //复制构造在形式结合时发生，如果传引用则不会调用复制构造函数
{
	cout << p.get_X() << endl;
}

Point fun2()
{
	Point a(5);
	return a;                              //复制构造在此处发生
}

void fun3(Point &p)                      //复制构造在形式结合时发生，如果传引用则不会调用复制构造函数
{
	cout << p.get_X() << endl;
}

int main()
{
	Point a(2,4);            
	Point c;
	c = a;                                  //赋值构造函数的调用
	                                        //以下三种情况对应上述的三种情况
	Point b(a);                             //复制构造发生的第一种情况：用a去初始化b
	//fun1(b);                                //复制构造发生的第二种情况：b作为fun1的实参
	//b = fun2();                             //复制构造发生的第三种情况：函数的返回类型为类类型
	//fun3(b);                                //传引用的时候是不需要调用复制构造函数的
	cout << b.get_X() << endl;
	cout << b.get_Y() << endl;



	system("pause");
	return 0;
}

